//! Example: Real-time Email IDLE Push Notifications
//!
//! This example demonstrates how to use the Flow Desk email engine with real-time
//! IDLE push notifications for immediate email delivery without manual refresh.
//!
//! Features demonstrated:
//! - IMAP IDLE connections for real-time notifications
//! - Background sync triggering on new messages
//! - Connection resilience and reconnection
//! - UI notification system integration
//! - Multi-account support

use flow_desk_mail::{
    init_mail_engine, MailAccount, MailEngineConfig, MailProvider, ProviderAccountConfig,
    AuthConfig, SyncConfig, RateLimitConfig, NotificationListener, UINotification,
    MailAccountStatus,
};
use std::collections::HashMap;
use tokio::sync::mpsc;
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing for logging
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();

    println!("ðŸš€ Starting Flow Desk Email IDLE Notifications Example");

    // Step 1: Create mail engine configuration
    let config = MailEngineConfig {
        database_path: "example_mail.db".to_string(),
        auth_config: AuthConfig {
            google_client_id: "your-gmail-client-id".to_string(),
            google_client_secret: "your-gmail-client-secret".to_string(),
            microsoft_client_id: "your-outlook-client-id".to_string(),
            microsoft_client_secret: "your-outlook-client-secret".to_string(),
            redirect_uri: "http://localhost:8080/callback".to_string(),
        },
        sync_config: SyncConfig {
            sync_interval_seconds: 300,
            max_concurrent_syncs: 5,
            batch_size: 100,
            retry_attempts: 3,
            enable_push_notifications: true, // Enable push notifications
        },
        rate_limiting: RateLimitConfig {
            gmail_requests_per_second: 10,
            outlook_requests_per_second: 20,
            imap_concurrent_connections: 3,
        },
    };\n\n    // Step 2: Initialize the mail engine\n    let mut engine = init_mail_engine(config).await?;\n    println!(\"âœ… Mail engine initialized\");\n\n    // Step 3: Initialize real-time notifications\n    engine.initialize_notifications().await?;\n    println!(\"âœ… Notification system initialized\");\n\n    // Step 4: Create UI notification listener\n    let (ui_sender, mut ui_receiver) = mpsc::unbounded_channel::<UINotification>();\n    let notification_listener = NotificationListener {\n        ui_sender,\n        account_filter: None, // Listen to all accounts\n        folder_filter: None,  // Listen to all folders\n    };\n\n    // Add the listener to the engine\n    engine\n        .add_notification_listener(\"main_ui\".to_string(), notification_listener)\n        .await?;\n    println!(\"âœ… UI notification listener added\");\n\n    // Step 5: Add email accounts (examples for different providers)\n    let accounts = vec![\n        // Gmail account example\n        create_gmail_account(\"your-gmail@gmail.com\"),\n        // IMAP account example\n        create_imap_account(\"your-email@example.com\", \"imap.example.com\", \"smtp.example.com\"),\n    ];\n\n    let mut account_ids = Vec::new();\n    for account in accounts {\n        match engine.add_account(account.clone()).await {\n            Ok(account_id) => {\n                println!(\"âœ… Added account: {} ({})\", account.email, account_id);\n                account_ids.push(account_id);\n            }\n            Err(e) => {\n                println!(\"âŒ Failed to add account {}: {}\", account.email, e);\n            }\n        }\n    }\n\n    // Step 6: Enable notifications for all accounts\n    for account_id in &account_ids {\n        match engine.enable_account_notifications(*account_id).await {\n            Ok(_) => println!(\"ðŸ”” Enabled notifications for account {}\", account_id),\n            Err(e) => println!(\"âŒ Failed to enable notifications for {}: {}\", account_id, e),\n        }\n    }\n\n    // Step 7: Start background sync\n    engine.start_sync().await?;\n    println!(\"ðŸ”„ Background sync started\");\n\n    // Step 8: Listen for real-time notifications\n    println!(\"ðŸŽ§ Listening for real-time email notifications...\");\n    println!(\"ðŸ“§ Send yourself an email to see real-time notifications!\");\n    println!(\"Press Ctrl+C to stop\\n\");\n\n    // Handle notifications in a separate task\n    let notification_task = tokio::spawn(async move {\n        while let Some(notification) = ui_receiver.recv().await {\n            handle_ui_notification(notification).await;\n        }\n    });\n\n    // Step 9: Monitor system health\n    let health_task = tokio::spawn(async move {\n        let mut interval = tokio::time::interval(std::time::Duration::from_secs(30));\n        loop {\n            interval.tick().await;\n            \n            // Check notification system health\n            if let Ok(Some(health)) = engine.get_notification_health().await {\n                println!(\"ðŸ“Š System Health: {} IDLE connections, {} active syncs, {} listeners\", \n                    health.idle_connections, health.active_syncs, health.listeners);\n                \n                if !health.is_healthy {\n                    println!(\"âš ï¸  System health warning detected!\");\n                }\n            }\n        }\n    });\n\n    // Step 10: Wait for shutdown signal\n    tokio::select! {\n        _ = tokio::signal::ctrl_c() => {\n            println!(\"\\nðŸ›‘ Shutdown signal received\");\n        }\n        _ = notification_task => {\n            println!(\"\\nâŒ Notification task ended unexpectedly\");\n        }\n        _ = health_task => {\n            println!(\"\\nâŒ Health monitoring task ended unexpectedly\");\n        }\n    }\n\n    // Step 11: Cleanup\n    println!(\"ðŸ§¹ Cleaning up...\");\n    \n    // Disable notifications for all accounts\n    for account_id in &account_ids {\n        let _ = engine.disable_account_notifications(*account_id).await;\n    }\n    \n    // Shutdown the engine\n    engine.shutdown().await?;\n    println!(\"âœ… Cleanup completed\");\n\n    Ok(())\n}\n\n/// Handle UI notifications from the email engine\nasync fn handle_ui_notification(notification: UINotification) {\n    match notification {\n        UINotification::NewEmail { account_id, folder, count, preview } => {\n            println!(\"ðŸ“¨ NEW EMAIL! Account: {}, Folder: {}, Count: {}\", account_id, folder, count);\n            \n            if let Some(preview) = preview {\n                println!(\"   ðŸ“„ From: {}\", preview.from);\n                println!(\"   ðŸ“‹ Subject: {}\", preview.subject);\n                println!(\"   ðŸ’¬ Snippet: {}\", preview.snippet);\n                println!(\"   ðŸ• Received: {}\", preview.received_at);\n            }\n            \n            // Here you would typically:\n            // - Show desktop notification\n            // - Update UI badge counts\n            // - Play notification sound\n            // - Update system tray icon\n            println!(\"   ðŸ”” Trigger desktop notification here!\");\n        }\n        \n        UINotification::EmailDeleted { account_id, folder, message_id } => {\n            println!(\"ðŸ—‘ï¸  Email deleted: {} in {} (account: {})\", message_id, folder, account_id);\n        }\n        \n        UINotification::EmailFlagsChanged { account_id, folder, message_id, is_read, is_starred } => {\n            println!(\"ðŸ·ï¸  Email flags changed: {} in {} (account: {})\", message_id, folder, account_id);\n            if let Some(read) = is_read {\n                println!(\"   ðŸ“– Read: {}\", read);\n            }\n            if let Some(starred) = is_starred {\n                println!(\"   â­ Starred: {}\", starred);\n            }\n        }\n        \n        UINotification::FolderUpdated { account_id, folder, total_count, unread_count } => {\n            println!(\"ðŸ“ Folder updated: {} (account: {})\", folder, account_id);\n            println!(\"   ðŸ“Š Total: {}, Unread: {}\", total_count, unread_count);\n        }\n        \n        UINotification::SyncStarted { account_id, folder } => {\n            println!(\"ðŸ”„ Sync started: {} (account: {})\", folder, account_id);\n        }\n        \n        UINotification::SyncCompleted { account_id, folder, messages_synced, success, error } => {\n            if success {\n                println!(\"âœ… Sync completed: {} (account: {}) - {} messages\", folder, account_id, messages_synced);\n            } else {\n                println!(\"âŒ Sync failed: {} (account: {})\", folder, account_id);\n                if let Some(err) = error {\n                    println!(\"   Error: {}\", err);\n                }\n            }\n        }\n        \n        UINotification::ConnectionStatusChanged { account_id, is_connected, last_error } => {\n            if is_connected {\n                println!(\"ðŸŸ¢ Connection restored for account {}\", account_id);\n            } else {\n                println!(\"ðŸ”´ Connection lost for account {}\", account_id);\n                if let Some(error) = last_error {\n                    println!(\"   Error: {}\", error);\n                }\n            }\n        }\n    }\n    \n    println!(); // Empty line for readability\n}\n\n/// Create a Gmail account configuration\nfn create_gmail_account(email: &str) -> MailAccount {\n    MailAccount {\n        id: Uuid::new_v4(),\n        user_id: Uuid::new_v4(),\n        name: format!(\"Gmail - {}\", email),\n        email: email.to_string(),\n        provider: MailProvider::Gmail,\n        provider_config: ProviderAccountConfig::Gmail {\n            client_id: \"your-gmail-client-id\".to_string(),\n            scopes: vec![\n                \"https://www.googleapis.com/auth/gmail.readonly\".to_string(),\n                \"https://www.googleapis.com/auth/gmail.send\".to_string(),\n                \"https://www.googleapis.com/auth/gmail.modify\".to_string(),\n            ],\n            enable_push_notifications: true, // Enable Gmail push notifications\n            history_id: None,\n        },\n        status: MailAccountStatus::Active,\n        last_sync_at: None,\n        next_sync_at: None,\n        sync_interval_minutes: 15,\n        is_enabled: true,\n        created_at: chrono::Utc::now(),\n        updated_at: chrono::Utc::now(),\n        config: ProviderAccountConfig::Gmail {\n            client_id: \"your-gmail-client-id\".to_string(),\n            scopes: vec![\n                \"https://www.googleapis.com/auth/gmail.readonly\".to_string(),\n                \"https://www.googleapis.com/auth/gmail.send\".to_string(),\n                \"https://www.googleapis.com/auth/gmail.modify\".to_string(),\n            ],\n            enable_push_notifications: true,\n            history_id: None,\n        },\n        sync_status: None,\n        display_name: format!(\"Gmail - {}\", email),\n        oauth_tokens: None,\n        imap_config: None,\n        smtp_config: None,\n    }\n}\n\n/// Create an IMAP account configuration\nfn create_imap_account(email: &str, imap_host: &str, smtp_host: &str) -> MailAccount {\n    MailAccount {\n        id: Uuid::new_v4(),\n        user_id: Uuid::new_v4(),\n        name: format!(\"IMAP - {}\", email),\n        email: email.to_string(),\n        provider: MailProvider::Imap,\n        provider_config: ProviderAccountConfig::Imap {\n            imap_host: imap_host.to_string(),\n            imap_port: 993,\n            imap_tls: true,\n            smtp_host: smtp_host.to_string(),\n            smtp_port: 587,\n            smtp_tls: true,\n            folder_mappings: HashMap::new(),\n        },\n        status: MailAccountStatus::Active,\n        last_sync_at: None,\n        next_sync_at: None,\n        sync_interval_minutes: 15,\n        is_enabled: true,\n        created_at: chrono::Utc::now(),\n        updated_at: chrono::Utc::now(),\n        config: ProviderAccountConfig::Imap {\n            imap_host: imap_host.to_string(),\n            imap_port: 993,\n            imap_tls: true,\n            smtp_host: smtp_host.to_string(),\n            smtp_port: 587,\n            smtp_tls: true,\n            folder_mappings: HashMap::new(),\n        },\n        sync_status: None,\n        display_name: format!(\"IMAP - {}\", email),\n        oauth_tokens: None,\n        imap_config: Some(flow_desk_mail::types::ImapConfig {\n            server: imap_host.to_string(),\n            host: imap_host.to_string(),\n            port: 993,\n            use_tls: true,\n            username: email.to_string(),\n            password: None, // Would be set during authentication\n        }),\n        smtp_config: Some(flow_desk_mail::types::SmtpConfig {\n            server: smtp_host.to_string(),\n            port: 587,\n            use_tls: true,\n            username: email.to_string(),\n            password: None, // Would be set during authentication\n        }),\n    }\n}"